# Snakes and Ladders

**Description:**

You are given an `n x n` integer matrix `board` where the cells are labeled from `1` to `n^2` in a [Boustrophedon style](https://en.wikipedia.org/wiki/Boustrophedon) starting from the bottom left of the board (i.e. `board[n - 1][0]`) and alternating direction each row.

You start on square `1` of the board. In each move, starting from square `curr`, do the following:

- Choose a destination square `next` with a label in the range `[curr + 1, min(curr + 6, n2)]`.
  - This choice simulates the result of a standard 6-sided die roll: i.e., there are always at most 6 destinations, regardless of the size of the board.
- If `next` has a snake or ladder, you must move to the destination of that snake or ladder. Otherwise, you move to `next`.
- The game ends when you reach the square `n^2`.

A board square on row `r` and column `c` has a snake or ladder if `board[r][c] != -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1` and `n^2` do not have a snake or ladder.

Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do not follow the subsequent snake or ladder.

- For example, suppose the board is [[-1,4],[-1,3]], and on the first move, your destination square is 2. You follow the ladder to square 3, but do not follow the subsequent ladder to 4.

Return the least number of moves required to reach the square `n^2`. If it is not possible to reach the square, return `-1`.

- `n == board.length == board[i].length`
- `2 <= n <= 20`
- `board[i][j]` is either `-1` or in the range `[1, n^2]`.
- The squares labeled `1` and `n^2` do not have any ladders or snakes.

**Examples:**

```text
Input: board = [[-1,-1,-1,-1,-1,-1],
                [-1,-1,-1,-1,-1,-1],
                [-1,-1,-1,-1,-1,-1],
                [-1,35,-1,-1,13,-1],
                [-1,-1,-1,-1,-1,-1],
                [-1,15,-1,-1,-1,-1]]
Output: 4

Input: board = [[-1,-1],
                [-1,3]]
Output: 1
```

## Overview

I first wrote a [depth-first](asdasd) solution. This was unaccepted by LeetCode for running over a time-limit. A description of my [breadth-first](asd) is what follows.

1. We grab some initial values of the dimension of the board to generate a board that is 1-dimensional.
    - This allows us to better iterate through using the values representing pointers to indexes,
      rather than "positions on the board" which would have to be translated to this Boustrophedon
      style.
    - `new_board` is our 1-D board, generated by `reduce_board()`.
2. Inside `find_least()` we're repeatedly building a queue to look at next positions available, `temp_queue`, from our reach of current positions, `queue`.
    - Each time we finish clearing our looked-at positions, we can increment our `step_count`.
    - This function stops when we find our position at the `self.last_index`, could reach it, or placed
      there by ladder.
    - This function calls on `find_next_steps()` to return a list of positions of interest within 6
      position from our current position. This is to reduce steps taken unnecessarily on "small dice rolls" that would be reached by a higher "dice roll".

Between the two solutions, the depth-first `snakes_and_ladders.py` (1) uses more instance variables to share values across the functions, and (2) doesn't reduce the 2-D list for more efficient calls to variables like the other.

The breadth first search is faster, likely in a combination of (1) the reducing of the 2-D list, (2) using less logic, recursion and copying of lists, and (3) being breadth-first.

## Tests

### Unit Testing

We implemented unit-tests for this problem with `import unittest`. We designed them for code-coverage, testing edge-cases, and general confidence.

We ran this for both solutions.

We checked for:

- LeetCode's two example cases.
- No ladders/snakes.
- An immediate shortcut.
- An impossible case.
- A case where the player would have to miss many snakes consecutively.
- A case where the shortest path involves going forward and back.
- A case where the shortest path is NOT two ladders leading into each other.
  - Displays the effect of taking one ladder not taking to the destination of another ladder.
- A max-length board with no snakes/ladders.
- A ladder that takes precisely to last position.
- A case that caused a time-limit-exceeded error on LeetCode.
  - Likely too much branching on the depth-first search.

### Code Coverage

We received 100% code coverage on my methods from the unit-test using the `coverage.py` tool.

```PowerShell
> coverage run -m unittest
> coverage report
Name                      Stmts   Miss  Cover
---------------------------------------------
snakes_and_ladders.py        56      0   100%
snakes_and_ladders_2.py      58      0   100%
test_unittests.py           123      0   100%
testcases.py                 59      0   100%
---------------------------------------------
TOTAL                       296      0   100%
```

### Memory Usage Testing

I used `tracemalloc` to look at peak memory block usage during the running of my solution `snakes_and_ladders()` against the other solution `snakes_and_ladders_2()`.

**Test 10:** A generated 20x20 board of no snakes/ladders.

Memory blocks used:

- `snakes_and_ladders()`: 27592 blocks
- `snakes_and_ladders_2()`: 9656 blocks

### Process Time Testing

I used `timeit` to isolate the individual functions on a test cases.

**Test 10:** A generated 20x20 board of no snakes/ladders.

- `snakes_and_ladders()`: 1.291 x 10^-4 sec
- `snakes_and_ladders_2()`: 0.844 x 10^-4 sec

**Test 7:** A board where the player must avoid many snakes to complete.

- `snakes_and_ladders()`: 8.429 x 10^-5 sec
- `snakes_and_ladders_2()`: 1.669 x 10^-5 sec

## Reflections

Trying to optimize a depth-first search of this with caching the visited paths was a headache. There was so much memory being used in copies of the visited path list into recursion. Also, the copying of lists may have been a time sink.

Some of the comments for this problem reflect on how the twisting method of the board adds unnecessary complexity to this problem. It does add some effort. I take this problem as heavier exercise in translating a client's description, requirements and constraints.
